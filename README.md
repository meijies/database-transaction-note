# 并发控制
## 阅读之前的问题？
1. 事务处理器应该表现出确定状态机的特质，这意味着对于相同的输入，该事务处理器总
   能最终得到相同的结果。这个问题的意义在于事务结果能够延迟写入磁盘从而获得顺序
   IO。
2. MVCC如何解决大量冲突的问题？以及重试

## 解决了什么问题？
+ 可串行性
+ 冲突可串行性

## 解决问题的手段
+ 封锁
+ 时间戳
+ 有效性确认

## 记法
$r_i(X)和w_i(X)$表示事务Ti读和写X元素， $T_i$表示具有下标i的动作序列$，事务集合T
的调度S是一个动作序列

## 冲突可串行化
**1)冲突**
+ 它们涉及统一数据库元素
+ 至少由一个是写操作

我们可以接受任一调度，进行任意非冲突的交换，目标是将该调度转换为一个串行调度。
（事务的执行顺序是可以改变的，只要执行的结果是一致的。这种也可用于减轻冲突。）

**2)冲突等价**
如果通过一系列相邻动作的非冲突交换能将它们中的一个转换为另一个，我们说两个调度是
冲突等价的。（呼应一得出的结论）

如果一个调度冲突等价于一个串行调度，那么该调度就是冲突可串行化。冲突可串行化是可
串行化的一个充分条件。它是商业系统中的调度器在需要保证可串行化是通常使用的条件。

## 优先图及可串行化判断
一个事务中包括多个操作，事务调度器对不同事务的操作进行调度。这里的优先图也是根据
这些操作的顺序画出来的。

已知调度S，其中涉及事务$T_1$和$T_2$, 可能还有其他事务，我们说$T_1$优先于$T_2$,写
作$T_1 < _sT_2$, 如果有$T_1$的动作$A_1$和$T_2$的动作$A_2$, 满足：
+ 在S中$A_1$在$A_2$之前
+ $A_1$和$A_2$都涉及同一数据库元素
+ $A_1$和$A_2$中至少有一个是写动作

优先：表达的不能交换$A_1$和$A_2$的情况。
我们可以在优先图中概括这样的先后次序。优先图的节点是调度S中的事务。

我们可以构造 S的优先图，并判断其中是否有环来判断调度S是否冲突可串行化。如果有，
那么S不是冲突可串行化。

## 基于锁的可串行化实现
**1)事务的一致性**
+ 事务只有先前以及在数据库元素上被授予了锁并且还没有释放锁时，才能读或者写该数据
  库元素。
+ 如果数据库封锁了某个数据库元素，那么它以后必须为这个元素解锁。

**2)调度的合法性**
+ 任何两个事务都不能封锁同一元素，除非其中一个事务已经先释放锁了。

**3)锁的记法**
$l_i(X)$：事务$T_i$请求数据库元素X上的锁
$u_i(X)$：事务$T_i$释放它在数据库元素X上的锁


**4)封锁调度器**
封锁将延迟执行某个事务的调度任务，直到该锁释放。

**5)两阶段锁**
+ 在每个事务中，所有封锁请求先于所有解锁请求。

## 多种锁模式的封锁系统
+ 共享锁/读锁
+ 排他锁/写锁

1. 事务的一致性。如果不是持有排他锁就不能写，并且如果不是持有某个锁就不能读
   + 读动作$r_i(X)$之前必须有$sl_i(X)$或$xl_i(X)$， 而且它们中间没有$u_i(X)$
   + 写动作$w_i(X)$之前必须有$xl_i(X)$,而且它们中间没有$u_i(X)$
2. 事务的两阶段分所。封锁必须在解锁之前。对于某个事务$T_i$中，任何$sl_i(X)$或
   $xl_i(X)$动作之前不能有$u_j(Y)$。（这里表明的意思是在某个事务中，释放锁操作不
   能在任何加锁操作之前）
3. 调度的合法性。一个元素可以被一个事务排他的封锁，或者被一个事务共享的封锁，但
   不能二者兼有。
  
### 相容性矩阵
描述锁-管理策略的简单方法。

|   | S  | X  |
| S | 是 | 否 |
| X | 否 | 否   |

### 锁的升级
将读锁升级为写锁，只能在某个元素只有一个排他锁的情况下进行升级，否则需要拒绝。

### 更新锁
用来避免一般死锁的一种方法

更新锁$ul_i(X)$只基于事务$T_i$读X而不是写X的权限。但是只有更新锁在之后升级为写锁,
读锁是不能升级的。当X上已经有共享锁的时候，我们可以授予X上的更新锁。但是一旦X上
有更新锁,就禁止X上加其他任何种类的锁。否则更新锁上可能有其他锁，导致永远无法升级
到排他锁。

|   | S  | X  | U  |
| S | 是 | 否 | 是 |
| X | 否 | 否 | 否 |
| U | 否 | 否 | 否 |

### 增量锁 TODO (增量操作能做到原子？)
很多事务只能通过增加或减少存储的值来对数据库进行操作。
+ 增量动作一个有用的性质是这些动作相互之间是可以交换的。
+ 增量与读或者写都不能交换。

将增量作为事务中一种可能的动作引入INC(A, c)。非正式的表示为将常数c加到A上。
INC(A, c) = READ(A, t); t: = t + c; WRITE(A, t)。

与增量动作对于我们需要一个增量锁。用$il_i(X)$表示。简单的记法是$inc_i(X)$
+ 一致的事务只有在它持有X上的增量锁时才能在X上进行增量动作，但增量锁并不能赋予读
  或者写的权利。
+ 在一个合法调度中，任何时候可以有多个事务在X上持有增量锁。但是如果某个事务持有X
  上的增量锁，那么其他事务同时在X上既不能持有共享锁也不能持有排他锁。
  

## 封锁调度器的体系结构
+ 事务自身不申请锁
+ 事务不释放锁

![调度器体系结构](transaction_schedule_structure.png "调度器体系结构")

1. 第一部分接受事务请求流，并在操作数据库前插入适当的锁动作。不管调度器使用什么
   样的封锁模式集合，调度器的第一部分必须从其中选择适当的封锁方式。
2. 第二部分接受由第一部分传来的分所和数据库访问动作序列，并正确地执行它们中的每
   一个。
3. 当事务T提交或者种植，事务管理器将通知第一部分释放T持有的所有的锁。如果有事务
   等待这些锁中的任何一个，第一部分将通知第二部分。
4. 第二部分被告知某个数据库元素X上的锁可以获得时，它决定加下来能或的X上的锁的一
   个或多个事务。获得锁的这个（或这些）事务经可能的执行，知道它们完成或到达另一
   个不能被授予的事务。
   
### 锁表
将数据库元素与该元素的封锁信息联系起来的一个关系表。
