# 并发控制
## 阅读之前的问题？
1. 事务处理器应该表现出确定状态机的特质，这意味着对于相同的输入，该事务处理器总
   能最终得到相同的结果。这个问题的意义在于事务结果能够延迟写入磁盘从而获得顺序
   IO。
2. MVCC如何解决大量冲突的问题？以及重试

## 解决了什么问题？
+ 可串行性
+ 冲突可串行性

## 解决问题的手段
+ 封锁
+ 时间戳
+ 有效性确认

## 记法
$r_i(X)和w_i(X)$表示事务Ti读和写X元素， $T_i$表示具有下标i的动作序列$，事务集合T
的调度S是一个动作序列

## 冲突可串行化
**1)冲突**
+ 它们涉及统一数据库元素
+ 至少由一个是写操作

我们可以接受任一调度，进行任意非冲突的交换，目标是将该调度转换为一个串行调度。
（事务的执行顺序是可以改变的，只要执行的结果是一致的。这种也可用于减轻冲突。）

**2)冲突等价**
如果通过一系列相邻动作的非冲突交换能将它们中的一个转换为另一个，我们说两个调度是
冲突等价的。（呼应一得出的结论）

如果一个调度冲突等价于一个串行调度，那么该调度就是冲突可串行化。冲突可串行化是可
串行化的一个充分条件。它是商业系统中的调度器在需要保证可串行化是通常使用的条件。

## 优先图及可串行化判断
一个事务中包括多个操作，事务调度器对不同事务的操作进行调度。这里的优先图也是根据
这些操作的顺序画出来的。

已知调度S，其中涉及事务$T_1$和$T_2$, 可能还有其他事务，我们说$T_1$优先于$T_2$,写
作$T_1 < _sT_2$, 如果有$T_1$的动作$A_1$和$T_2$的动作$A_2$, 满足：
+ 在S中$A_1$在$A_2$之前
+ $A_1$和$A_2$都涉及同一数据库元素
+ $A_1$和$A_2$中至少有一个是写动作

优先：表达的不能交换$A_1$和$A_2$的情况。
我们可以在优先图中概括这样的先后次序。优先图的节点是调度S中的事务。

我们可以构造 S的优先图，并判断其中是否有环来判断调度S是否冲突可串行化。如果有，
那么S不是冲突可串行化。

## 基于锁的可串行化实现
**1)事务的一致性**
+ 事务只有先前以及在数据库元素上被授予了锁并且还没有释放锁时，才能读或者写该数据
  库元素。
+ 如果数据库封锁了某个数据库元素，那么它以后必须为这个元素解锁。

**2)调度的合法性**
+ 任何两个事务都不能封锁同一元素，除非其中一个事务已经先释放锁了。

**3)锁的记法**
$l_i(X)$：事务$T_i$请求数据库元素X上的锁
$u_i(X)$：事务$T_i$释放它在数据库元素X上的锁


**4)封锁调度器**
封锁将延迟执行某个事务的调度任务，直到该锁释放。

**5)两阶段锁**
+ 在每个事务中，所有封锁请求先于所有解锁请求。

## 多种锁模式的封锁系统
+ 共享锁/读锁
+ 排他锁/写锁

1. 事务的一致性。如果不是持有排他锁就不能写，并且如果不是持有某个锁就不能读
   + 读动作$r_i(X)$之前必须有$sl_i(X)$或$xl_i(X)$， 而且它们中间没有$u_i(X)$
